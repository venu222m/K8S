| Reason                                        | Explanation                                                                                                                                                                                                                 |
| --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Secrets never stored in Kubernetes API** | The CSI driver mounts secrets **directly from AWS Secrets Manager** at pod runtime. They’re not copied into a Kubernetes `Secret`, so even if your cluster is compromised, secrets aren’t exposed via `kubectl get secret`. |
| **2. Least privilege with IRSA**              | Each app/service can have its own **IAM role** that grants read access to only the secrets it needs. You don’t rely on node-level IAM roles.                                                                                |
| **3. Auto rotation support**                  | If secrets are rotated in AWS Secrets Manager (e.g., DB password), the CSI driver can **auto refresh** them in the pod without redeploying.                                                                                 |
| **4. AWS-native integration**                 | Managed by AWS; officially supported; aligns with AWS security best practices.                                                                                                                                              |
| **5. Audit trail**                            | AWS CloudTrail logs every `GetSecretValue` call, so you can audit which pod accessed what and when.      

Prerequisites

kubectl configured to talk to your EKS cluster.

aws CLI configured with permissions to create IAM roles/policies and Secrets Manager objects.

eksctl (optional but convenient).

Helm v3.

Your EKS cluster must have OIDC provider enabled (IRSA uses OIDC).

If you don’t have OIDC set up:

# using eksctl (replace cluster name and region)
eksctl utils associate-iam-oidc-provider --cluster my-eks-cluster --region us-east-1 --approve

0 — Create a secret in AWS Secrets Manager

Example: secret with key DB_PASSWORD

aws secretsmanager create-secret \
  --name myapp/db-credentials \
  --secret-string '{"username":"dbuser","password":"S3cr3tP@ssw0rd"}' \
  --description "DB creds for myapp"


Copy the secret ARN from the output — you’ll need it.

Method A — Secrets Store CSI Driver + AWS Provider (recommended)
1. Install Secrets Store CSI Driver
kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/secrets-store-csi-driver/main/deployment/charts/secrets-store-csi-driver/crds/crds.yaml
helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
helm repo update
helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system

2. Install the AWS provider for the CSI driver

Provider repo provides a Helm chart or manifests. Example with Helm (replace chart source if needed):

helm repo add aws-secrets-provider https://aws.github.io/secrets-store-csi-driver-provider-aws
helm repo update
helm install secrets-store-provider-aws aws-secrets-provider/secrets-store-provider-aws --namespace kube-system


(If Helm chart location differs for your environment, use provider manifests from the provider-aws repo.)

3. Create IAM policy that allows reading the secret

Create a JSON policy (allow secretsmanager:GetSecretValue for the secret ARN):
secrets-policy.json:

{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Effect":"Allow",
      "Action":["secretsmanager:GetSecretValue", "secretsmanager:DescribeSecret"],
      "Resource":["arn:aws:secretsmanager:us-east-1:123456789012:secret:myapp/db-credentials-abc123"]
    }
  ]
}


Create policy:

aws iam create-policy --policy-name EKSReadSecretMyApp --policy-document file://secrets-policy.json


Note the policy ARN returned.

4. Create IAM role for the Kubernetes ServiceAccount (IRSA)

Replace OIDC_PROVIDER and ARNs appropriately. You can create a role and attach the policy using eksctl or AWS CLI. Example with eksctl:

eksctl create iamserviceaccount \
  --name secret-reader-sa \
  --namespace default \
  --cluster my-eks-cluster \
  --attach-policy-arn arn:aws:iam::<ACCOUNT_ID>:policy/EKSReadSecretMyApp \
  --approve \
  --override-existing-serviceaccounts


If you prefer CLI/manual role creation, create role with trust policy allowing the cluster OIDC provider and subject system:serviceaccount:default:secret-reader-sa.

5. Create a SecretProviderClass (Kubernetes CRD) that maps to your AWS secret

secretproviderclass.yaml:

apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: aws-secrets-myapp
spec:
  provider: aws
  parameters:
    # the ARN of your Secrets Manager secret
    objects: |
      - objectName: "arn:aws:secretsmanager:us-east-1:123456789012:secret:myapp/db-credentials-abc123"
        objectType: "secretsmanager" 
        # Optional: specify version or key mapping if you want a specific field


Apply it:

kubectl apply -f secretproviderclass.yaml

6. Deployment that mounts the secret via CSI

deployment.yaml:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 1
  selector:
    matchLabels: { app: myapp }
  template:
    metadata:
      labels: { app: myapp }
    spec:
      serviceAccountName: secret-reader-sa   # the IRSA bound SA
      containers:
      - name: myapp
        image: nginx
        volumeMounts:
        - name: secrets-store-inline
          mountPath: "/mnt/secrets"   # files will appear here
          readOnly: true
      volumes:
      - name: secrets-store-inline
        csi:
          driver: secrets-store.csi.k8s.io
          readOnly: true
          volumeAttributes:
            secretProviderClass: "aws-secrets-myapp"


Apply it:

kubectl apply -f deployment.yaml

